<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello</title>
    <url>/2024/12/22/Hello/</url>
    <content><![CDATA[<p>我渴望像风一样自由地飞翔，无拘无束地探索。<br>然而，心中总有那份温柔的牵绊。<br>你好，我的世界！<br>我既向往远方，也珍惜此刻的温暖。<br>Hello World!</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Start</title>
    <url>/2024/12/13/Start/</url>
    <content><![CDATA[<h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><h4 id="Install-Git"><a href="#Install-Git" class="headerlink" title="Install Git"></a>Install Git</h4><p>Windows: Download &amp; install <a href="!https://git-scm.com/downloads/win">git</a>.<br>Mac: Install it with Homebrew, MacPorts or installer.</p>
<h4 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h4><p>Node.js 为大多数平台提供了官方的<a href="!https://nodejs.org/zh-cn/download/prebuilt-installer">安装程序</a>。<br>参考<a href="!https://blog.csdn.net/Nicolecocol/article/details/136788200">链接</a>。</p>
<h4 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h4><p>使用 npm 安装 Hexo</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>验证是否安装成功  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo version</span><br></pre></td></tr></table></figure>
<p>简易安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo</span><br></pre></td></tr></table></figure>
<p>参考<a href="!https://hexo.io/zh-cn/docs/index.html">链接</a></p>
<h4 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h4><p>1, 使用git下载第二个文件夹到本地文件夹,例如：file_floder</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/***</span><br></pre></td></tr></table></figure>
<p>建议使用github <a href="!https://github.com/apps/desktop">desktop</a>,便于下载与上传文件。</p>
<p>2，打开文件夹，在source&#x2F;post&#x2F; 里新建 new.md 文件，编辑内容即可。<br>建议使用vs code或者 notepad 打开文件夹。</p>
<p>3，编译，预览，上传<br>在 file_floder 打开cmd或者power shell;<br>第一步：清楚历史编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure>
<p>第二步：编译</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure>
<p>第三步：执行操作，本地浏览器打开 <a href="http://localhost:4000/">http://localhost:4000/</a> 预览 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<p>上传到github， 通过 <a href="https://long-drong.github.io/">https://Long-drong.github.io/</a> 可查看博客。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Diary</category>
      </categories>
      <tags>
        <tag>Test</tag>
        <tag>使用说明</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello hexo</title>
    <url>/2024/12/22/hello-hexo/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>传感器噪声</title>
    <url>/2024/12/22/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E4%BC%A0%E6%84%9F%E5%99%A8%E5%99%AA%E5%A3%B0/</url>
    <content><![CDATA[<ul>
<li>噪声的颜色分类<ul>
<li>白噪声 white noise<br>如果噪声信号的功率谱密度接近均匀分布，此噪声即为白噪声，包括热噪声、散粒噪声等；</li>
<li>有色噪声 colored noise<br>如果噪声信号的功率谱密度是非均匀的，此噪声即为有色噪声，包括布朗噪声、红噪声、粉红噪声等；</li>
<li>色噪 chromatic noise<br>一般将色噪定义为低频噪声，同时也可以将色噪看做是图像在空域中具有一定自相关性的噪声。在图像当中常表现为彩色斑块，通常呈红、蓝色，尤其是在底图像质量的暗区。</li>
<li>有色噪声更多的是从频域的视角对噪声的频率响应进行描述，色噪更多的是从空域的角度对噪声的空间形态进行表述</li>
</ul>
</li>
<li>噪声建模与去噪<ul>
<li>图像中存在两种噪声：信号相关噪声与信号不相关噪声，数学上用泊松与高斯分布模型来描述。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像处理的基本分类</title>
    <url>/2024/12/22/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<h2 id="图像处理的基本分类"><a href="#图像处理的基本分类" class="headerlink" title="图像处理的基本分类"></a>图像处理的基本分类</h2><p>图像去噪、修复、视频超分辨率、滤镜、后聚集、增强，Demosaic，HDR，NR、SR、分割、识别等图像增强相关算法。<br><br/><br>图像去噪：去除图像中的噪声（如随机像素值变化），以提高图像质量。 <br/><br>图像修复：恢复受损或缺失的部分，使图像看起来完整且自然。<br><br/><br>视频超分辨率：将低分辨率视频转换为高分辨率视频，以提高清晰度和细节水平。<br><br/><br>滤镜：对图像进行各种视觉效果处理，例如色彩校正、模糊、锐化等。<br><br/><br>后聚焦：模拟相机重新对焦的效果，允许用户选择图像中的焦点区域。<br><br/><br>增强：改善图像的整体外观，使其更具吸引力或更容易阅读。<br><br/><br>Demosaicing：用于从单色传感器数据生成全彩色图像的过程。<br><br/><br>HDR（高动态范围）：合并多个曝光图像以创建包含宽广亮度范围的单一图像。<br><br/><br>NR（噪声减少）：降低图像中的噪声，以获得更平滑的结果。<br><br/><br>SR（超级分辨率）：提高图像分辨率，增加细节和清晰度。<br><br/><br>分割：将图像分割成不同的对象或区域，以便于分析或编辑。<br><br/><br>识别：自动检测和识别图像中的物体、人物或其他特征。</p>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>双边滤波器</title>
    <url>/2024/12/22/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2%E5%99%A8/</url>
    <content><![CDATA[<h2 id="双边滤波器"><a href="#双边滤波器" class="headerlink" title="双边滤波器"></a>双边滤波器</h2><p>双边滤波（Bilateral Filtering）是一种非线性的图像处理方法，主要用于图像的平滑同时保持边缘清晰。与传统的低通滤波器（如均值滤波或高斯滤波）不同，双边滤波不仅考虑了空间上的邻近性，还考虑了像素值的相似性，这使得它能够在去除噪声的同时较好地保留图像的边界和细节。</p>
<p>双边滤波可以这样理解，在高斯滤波的基础上添加了像素值的权重项，既要考虑距离因素，也要考虑像素值差异的影响。将像素值权重表示为，空间距离权重表示为。  </p>
<p>$$<br> Stashed changes<br>G_{p i x&#x3D;} \exp \left(-\frac{\left|I_{p}-I_{q}\right|^{2}}{2 \sigma_{p i x}^{2}}\right)<br>$$</p>
<p>$$<br>G_{d i s&#x3D;} \exp \left(-\frac{\left|p-q\right|^{2}}{2 \sigma_{d i s }^{2}}\right)<br>$$</p>
<p>BF滤波器可表示为：<br><img src="https://s2.loli.net/2024/10/06/zoGkt8dVaWBDPNx.png" alt="gongshi2.png"></p>
<p>其中Wq 为滤波窗口内每个像素值的权重和，用于权重的归一化；<br><img src="https://s2.loli.net/2024/10/06/HQOjSIKqzBG5h1F.png" alt="gongshi3.png"></p>
<p>实现过程:<br>1.确定滤波窗口：选择一个中心像素，并确定其邻域范围，这个范围通常是一个 N×N的窗口。<br>2.计算权重：对于窗口内的每一个像素，计算其空间高斯权重和值高斯权重，并将两者相乘得到最终的权重。<br>3.归一化权重：为了保证滤波后像素值的有效性，需要对所有权重进行归一化处理。<br>4.应用滤波：将窗口内所有像素值与其对应的权重相乘，然后求和，最后除以归一化因子 ，得到中心像素的新值。<br>5.遍历整个图像：重复步骤1至4，直到所有像素都被处理完毕。  </p>
<p>双边滤波由于其复杂性，在实际应用中可能会比简单的滤波器运行得更慢，但它能更好地保持图像的结构和细节。在计算机视觉和图像处理领域，双边滤波被广泛应用于去噪、边缘保护、纹理分离等任务。  </p>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像降噪算法概述</title>
    <url>/2024/12/22/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%BE%E5%83%8F%E9%99%8D%E5%99%AA%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="图像降噪算法概述"><a href="#图像降噪算法概述" class="headerlink" title="图像降噪算法概述"></a>图像降噪算法概述</h2><p>图像降噪是图像预处理中非常重要的一步，旨在去除图像中的噪声，以提高图像质量并为后续的图像分析提供更好的基础。图像降噪算法可以根据其原理和技术进行分类，主要包括以下几个大类：</p>
<h3 id="1-空域滤波方法"><a href="#1-空域滤波方法" class="headerlink" title="1. 空域滤波方法"></a>1. 空域滤波方法</h3><p>这些方法直接在像素级别上操作，通常涉及邻域内像素值的加权平均。</p>
<p>均值滤波：简单地取一个窗口内的所有像素的平均值，适用于均匀分布的噪声。<br>中值滤波：选择窗口内像素值的中位数，对于盐椒噪声特别有效。<br>高斯滤波：使用高斯核对邻域像素进行加权平均，可以平滑图像同时保留边缘信息。<br>双边滤波：结合空间邻近性和灰度相似性进行加权平均，既能去噪又能保持边缘。</p>
<h3 id="2-频域滤波方法"><a href="#2-频域滤波方法" class="headerlink" title="2. 频域滤波方法"></a>2. 频域滤波方法</h3><p>通过傅立叶变换将图像从空域转换到频域，然后对频谱进行操作。</p>
<p>低通滤波器：抑制高频分量，可以去除噪声但可能会模糊细节。<br>带通滤波器：允许特定频率范围内的信号通过，用于去除特定频率的噪声。</p>
<h3 id="3-变换域方法"><a href="#3-变换域方法" class="headerlink" title="3. 变换域方法"></a>3. 变换域方法</h3><p>利用图像在某种变换域下的特性进行降噪。</p>
<p>小波变换：通过小波系数阈值化去除噪声，保留图像细节。<br>离散余弦变换 (DCT) 或 离散傅立叶变换 (DFT)：类似频域滤波，但在变换域进行操作。</p>
<h3 id="4-基于统计的方法"><a href="#4-基于统计的方法" class="headerlink" title="4. 基于统计的方法"></a>4. 基于统计的方法</h3><p>利用图像的统计特性进行降噪。</p>
<p>非局部均值去噪 (NLM)：利用图像中相似区域的统计信息。<br>自适应滤波：根据局部图像的统计特性调整滤波参数。</p>
<h3 id="5-基于模型的方法"><a href="#5-基于模型的方法" class="headerlink" title="5. 基于模型的方法"></a>5. 基于模型的方法</h3><p>建立噪声模型，然后基于模型进行降噪。</p>
<p>贝叶斯估计：基于先验知识和观测数据估计最可能的原始图像。<br>隐马尔可夫模型 (HMM) 或马尔科夫随机场 (MRF)：考虑像素间的相互依赖关系。</p>
<h3 id="6-深度学习方法"><a href="#6-深度学习方法" class="headerlink" title="6. 深度学习方法"></a>6. 深度学习方法</h3><p>利用神经网络自动学习图像的复杂特征。</p>
<p>卷积神经网络 (CNN)：用于图像分类、识别和降噪。<br>生成对抗网络 (GAN)：特别是用于超分辨率和图像恢复。<br>自动编码器 (AE)：通过学习输入数据的压缩表示来进行降噪。<br>每种方法都有其适用场景和局限性，实际应用中可能需要结合多种技术来达到最佳效果;</p>
<p>结构示意图如下：</p>
<p><img src="https://s2.loli.net/2024/10/06/53bfFpQYrWEetkH.png" alt="Image_denoise_class.png">
   </p>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图像纹理基础知识</title>
    <url>/2024/12/22/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E5%9B%BE%E5%83%8F%E7%BA%B9%E7%90%86%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>纹理是物体表面固有的一种特性，所以图像中的区域常体现出纹理性质。纹理可以认为是灰度（颜色）在空间以一定的形式变化而产生的团（模式）。纹理与尺度有密切的关系，一般仅在一定的尺度上可以观察到，对纹理的分析需要在恰当的尺度上进行。纹理还具有区域性质的特点，通常被看做对局部区域中像素之间关系的一种度量，对于单个像素来说讨论纹理是没有意义的。一把情况下目前常用的纹理分析方法中有以下三种：统计法，结构法，频谱法。</p>
<h3 id="1-纹理描述的统计方法"><a href="#1-纹理描述的统计方法" class="headerlink" title="1. 纹理描述的统计方法"></a>1. 纹理描述的统计方法</h3><p>最简单的统计法借助于灰度直方图的矩来描述纹理，比如直方图的二阶矩是灰度对比度的度量，可以用于描述直方图的相对平滑程度；三阶矩表示了直方图的偏度；四阶矩表示的直方图的相对平坦型等等。但是仅借助灰度直方图的矩来描述纹理没能利用像素相对位置的空间信息，为了利用这些信息，我们可以建立区域的灰度共生矩阵。</p>
<h4 id="1-1-灰度共生矩阵"><a href="#1-1-灰度共生矩阵" class="headerlink" title="1.1 灰度共生矩阵"></a>1.1 灰度共生矩阵</h4><p>设 S 为目标区域 R 中具有特定空间联系（可由位置算子确定）的象素对的集合，共生矩阵 P 中的元素（ #代表数量）</p>
<p>分子：具有某种空间关系、灰度值分别为g1和g2的象素对的个数。分母：象素对的总和个数<br>上面提到了一个概念，位置算子，位置算子其实就是象素对的特定空间联系，比如向右1个象素和向下1个象素。共生矩阵的大小一般为k x k矩阵（k为所求图像的灰度级数）。举个例子如下：<br><img src="https://s2.loli.net/2024/10/27/HfkV538KWRPDETu.png" alt="12.png"><br>上图a为3个灰度级的图象（ g1 &#x3D; 0， g2 &#x3D; 1， g3 &#x3D; 2），位置算子为：向右1个象素和向下1个象素，b图按照位置算子计算得到的灰度共生矩阵，c图为共生矩阵归一化的结果。然而，为了更好的对图像分析，一般常用由共生矩阵产生的纹理描述符，比如：二阶矩，对应图像的均匀性或平滑性；熵，给出图像内容随机性的度量；对比度，反应紧邻像素间的反差等。</p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ol>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIzNDM2OTMzOQ==&chksm=e8f63ec3df81b7d588d7eabd04bcad1aec840449c4eb265a4e0068b00496f6cbf62295bcbdc3&idx=1&mid=2247485079&scene=21&sn=ca11aeccee0a4856aae00a1bdf1502a0#wechat_redirect">纹理图像分析的基本方法简述</a></li>
</ol>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>空域滤波算法</title>
    <url>/2024/12/22/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E7%A9%BA%E5%9F%9F%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="空域滤波算法"><a href="#空域滤波算法" class="headerlink" title="空域滤波算法"></a>空域滤波算法</h2><p>空域滤波算法是图像处理中用于去除噪声的一类方法，它们直接在图像的像素坐标系中操作，通过分析图像中像素与周围像素的关系来去除噪声。以下是几种常见的空域滤波算法的原理描述及其在MATLAB中的实现代码。</p>
<h3 id="1-均值滤波"><a href="#1-均值滤波" class="headerlink" title="1. 均值滤波"></a>1. 均值滤波</h3><p>均值滤波是一种简单的线性滤波方法，它通过替换图像中每个像素点的值为其邻域内所有像素值的平均值来实现降噪。MATLAB代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = imread(&#x27;lena.png&#x27;); % 读取图像</span><br><span class="line">h = fspecial(&#x27;average&#x27;, [5 5]); % 创建5x5的均值滤波器核</span><br><span class="line">filtered_img = imfilter(img, h); % 应用滤波器</span><br></pre></td></tr></table></figure>
<h3 id="2-中值滤波"><a href="#2-中值滤波" class="headerlink" title="2. 中值滤波"></a>2. 中值滤波</h3><p>中值滤波是一种非线性滤波方法，它通过替换图像中每个像素点的值为其邻域内所有像素值排序后的中值来实现降噪。这种方法对椒盐噪声特别有效。MATLAB代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = imread(&#x27;lena.png&#x27;); % 读取图像</span><br><span class="line">filtered_img = medfilt2(img); % 应用中值滤波</span><br></pre></td></tr></table></figure>

<h3 id="3-高斯滤波"><a href="#3-高斯滤波" class="headerlink" title="3. 高斯滤波"></a>3. 高斯滤波</h3><p>高斯滤波通过应用二维高斯函数作为滤波器核来平滑图像，适合去除高斯噪声。MATLAB代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = imread(&#x27;lena.png&#x27;); % 读取图像</span><br><span class="line">h = fspecial(&#x27;gaussian&#x27;, [5 5], 2); % 创建5x5的高斯滤波器核</span><br><span class="line">filtered_img = imfilter(img, h); % 应用滤波器</span><br></pre></td></tr></table></figure>
<h3 id="4-双边滤波"><a href="#4-双边滤波" class="headerlink" title="4. 双边滤波"></a>4. 双边滤波</h3><p>双边滤波是一种非线性空间滤波方法，它不仅考虑像素点的空间邻近性，还考虑像素值的相似性。这种滤波器在保持边缘清晰的同时去除噪声。MATLAB代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">img = imread(&#x27;lena.png&#x27;); % 读取图像</span><br><span class="line">h = fspecial(&#x27;gaussian&#x27;, [5 5], 2); % 创建5x5的空间滤波器核</span><br><span class="line">filtered_img = imfilter(img, h, &#x27;replicate&#x27;); % 应用双边滤波</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>非局部均值滤波器</title>
    <url>/2024/12/22/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/%E9%9D%9E%E5%B1%80%E9%83%A8%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2/</url>
    <content><![CDATA[<h2 id="非局部均值滤波器"><a href="#非局部均值滤波器" class="headerlink" title="非局部均值滤波器"></a>非局部均值滤波器</h2><p>NLM是一种基于图像块相似性的图像去噪方法，由Antoni Buades等人于2005年提出。与传统的基于像素的局部滤波方法不同，NLM利用了图像的自相似性原理，即图像中的大部分结构会在不同的位置重复出现。这种方法在保持边缘清晰度和细节的同时，有效地减少了噪声的影响。</p>
<h3 id="NLM降噪的基本步骤："><a href="#NLM降噪的基本步骤：" class="headerlink" title="NLM降噪的基本步骤："></a>NLM降噪的基本步骤：</h3><p>相似性度量： 对于图像中的每一个像素p，在图像的某个搜索区域内找到与该像素周围块（block）相似的其他块。相似度通常使用高斯核或指数函数来衡量，这取决于两个块之间的像素差异。<br>加权平均： 使用相似度作为权重，对所有相似块进行加权平均，得到目标像素的去噪估计值。权重越大意味着对应的块与目标像素周围的块越相似，因此对该像素的贡献也越大。<br>标准化： 在进行加权平均之前，通常会对权重进行归一化处理，确保所有权重的总和等于1，这样可以避免亮度的改变。</p>
<p>具体思路：<br>1，对当前点A定义较小一个滑动窗口（比如5 * 5）；<br>2，再对A定义一个较大的邻域范围（11 * 11），对邻域范围内所有的点取5*5的窗口。计算与A的窗口的差异；<br>3，计算所有点的差值的平方和，并利用该值来分配权重，并归一化处理；<br>4，通过加权平均计算A点新的像素值。</p>
<p><img src="https://s2.loli.net/2024/10/06/CXkhtvneL6b1jdJ.png" alt="shiyitu1.png"><br>NLM算法在处理自然图像时效果很好，因为它利用了图像的内在冗余和自相似性，但在处理具有高度纹理或复杂结构的图像时，可能需要调整参数以达到最佳效果。此外，NLM算法的计算量相对较大，因为需要在每个像素处执行块匹配和加权平均操作，这使得它在实时应用中可能受限.</p>
<p>可参考：<br>NLM去噪算法实现 - 羽凌寒 - CSDN博客  </p>
<blockquote>
<p><a href="https://blog.csdn.net/u011630458/article/details/5131741">https://blog.csdn.net/u011630458/article/details/5131741</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
</search>
